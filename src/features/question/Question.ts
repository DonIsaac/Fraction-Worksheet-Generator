import { randomInt, } from "../../lib"
import Fraction, { Strategies } from "./fraction"
import { Operation, QuestionGenerationConfig } from "./types"

/**
 * A practice problem for the user to solve. Questions are generated by the
 * desired generator function selected by the user.
 *
 * @see FractionGenerator
 */
export type Question =
    | Fraction
    | {
        operation: Operation
        left: Fraction
        right: Question
    }
    ;

export interface SolveQuestionOpts {

    /** Whether or not to simplify the solution. Defaults to `false`. */
    simplify?: boolean
}

/**
 * Calculates the solution to a Question.
 *
 * @param q     the question to solve.
 * @param opts  options to tweak solution behavior
 *
 * @returns     the solution to the Question.
 */
export const solveQuestion = (
    q: Question,
    opts: SolveQuestionOpts = {}
): Fraction => {
    const { simplify = false } = opts

    if (q instanceof Fraction) {
        return simplify ? q.simplify() : q
    }

    const { operation , left, right } = q

    switch (operation) {
        case Operation.Addition:
            return solveQuestion(left, opts).add(solveQuestion(right, opts))
        case Operation.Subtraction:
            return solveQuestion(left, opts).sub(solveQuestion(right, opts))
        case Operation.Multiplication:
            return solveQuestion(left, opts).mult(solveQuestion(right, opts))
        case Operation.Division:
            return solveQuestion(left, opts).div(solveQuestion(right, opts))
    }
}

/**
 * Creates a random question.
 *
 * @param args fraction and question generation settings
 *
 * @returns a newly created `Question`.
 *
 * @see Question
 */
export const generateQuestion: (
    args?: Partial<QuestionGenerationConfig>
) => Question = ({ // Arguments are unpacked/repacked to establish defaults
    operations = [Operation.Addition],
    strategy = "default",
    negative = false,
    range = [1, 10] as [number, number],
    countRange = [2, 3] as [number, number],
    mixedFractions = false,
} = {}) => _genQuestion({
    operation: operations[randomInt(0, operations.length)],
    negative,
    range,
    count:     randomInt(...countRange),
    strategy,
    mixedFractions,
})

type GenQuestionArgs = Required<Omit<QuestionGenerationConfig, "strategy" | "countRange" | "operations">> & {

    /** The fraction factory to use */
    strategy: Strategies

    /** The number of fractions in the question */
    count: number

    /** Arithmetic operation for this question subsection */
    operation: Operation
}
const _genQuestion: (args: GenQuestionArgs) => Question = args => {
    const {
        operation, negative, count, ...rest
    } = args
    const isNeg = negative && Math.random() < 0.5
    // const left: Fraction = gen({ negative: isNeg, ...rest })
    const left: Fraction = Fraction.generateFraction({
        negative: isNeg,
        ...rest,
    })

    return count <= 1
        ? left
        : {
            operation,
            left,
            right: _genQuestion({ ...args, count: count - 1 }),
        } as Question
}

export const symbolFor = (op: Operation): string => {
    switch (op) {
        case Operation.Addition: return "+"
        case Operation.Subtraction: return "-"
        case Operation.Multiplication: return "\u00d7"
        case Operation.Division: return "\u00f7"
    }
}
